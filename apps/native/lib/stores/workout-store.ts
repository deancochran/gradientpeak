import AsyncStorage from "@react-native-async-storage/async-storage";
import { create } from "zustand";
import { createJSONStorage, persist } from "zustand/middleware";
import { ActivityRecorderService } from "../services/activity-recorder";

export type WorkoutType =
  | "running"
  | "cycling"
  | "swimming"
  | "walking"
  | "hiking"
  | "strength_training"
  | "yoga"
  | "other";

export type WorkoutStatus =
  | "idle"
  | "recording"
  | "paused"
  | "completed"
  | "stopped";

export interface WorkoutMetrics {
  duration: number; // in seconds
  distance?: number; // in meters
  calories?: number;
  averageHeartRate?: number;
  maxHeartRate?: number;
  averageSpeed?: number; // in m/s
  maxSpeed?: number; // in m/s
  elevation?: number; // in meters
  averagePower?: number; // watts
  maxPower?: number; // watts
}

export interface WorkoutSettings {
  autoLap: boolean;
  autoLapDistance: number; // in meters
  pauseOnStop: boolean;
  gpsAccuracy: "high" | "medium" | "low";
  recordingInterval: number; // in milliseconds
  enableVoiceGuidance: boolean;
  enableHapticFeedback: boolean;
}

export interface ActiveWorkout {
  id: string;
  type: WorkoutType;
  name?: string;
  startTime: Date;
  endTime?: Date;
  status: WorkoutStatus;
  metrics: WorkoutMetrics;
  plannedActivityId?: string; // Reference to a planned workout
  settings: WorkoutSettings;
  autoGenerated: boolean;
}

export interface WorkoutState {
  // Current active workout
  activeWorkout: ActiveWorkout | null;

  // Recording state
  isRecording: boolean;
  isPaused: boolean;
  hasActiveSession: boolean;

  // Real-time metrics
  currentMetrics: WorkoutMetrics;

  // Settings
  workoutSettings: WorkoutSettings;

  // UI state
  showMetrics: boolean;
  selectedMetricView: "basic" | "advanced" | "zones";

  // Actions
  startWorkout: (
    type: WorkoutType,
    plannedActivityId?: string,
    name?: string,
  ) => Promise<void>;
  pauseWorkout: () => Promise<void>;
  resumeWorkout: () => Promise<void>;
  stopWorkout: () => Promise<void>;
  completeWorkout: () => Promise<void>;
  updateMetrics: (metrics: Partial<WorkoutMetrics>) => void;
  updateSettings: (settings: Partial<WorkoutSettings>) => void;
  setShowMetrics: (show: boolean) => void;
  setSelectedMetricView: (view: "basic" | "advanced" | "zones") => void;
  clearActiveWorkout: () => void;
  recoverWorkout: () => Promise<void>;
}

const defaultWorkoutSettings: WorkoutSettings = {
  autoLap: false,
  autoLapDistance: 1000, // 1km
  pauseOnStop: true,
  gpsAccuracy: "high",
  recordingInterval: 1000, // 1 second
  enableVoiceGuidance: true,
  enableHapticFeedback: true,
};

const defaultMetrics: WorkoutMetrics = {
  duration: 0,
};

export const useWorkoutStore = create<WorkoutState>()(
  persist(
    (set, get) => ({
      // Initial state
      activeWorkout: null,
      isRecording: false,
      isPaused: false,
      hasActiveSession: false,
      currentMetrics: defaultMetrics,
      workoutSettings: defaultWorkoutSettings,
      showMetrics: true,
      selectedMetricView: "basic",

      // Actions
      startWorkout: async (
        type: WorkoutType,
        plannedActivityId?: string,
        name?: string,
      ) => {
        try {
          const workoutId = `workout_${Date.now()}`;
          const startTime = new Date();

          const newWorkout: ActiveWorkout = {
            id: workoutId,
            type,
            name:
              name || `${type.charAt(0).toUpperCase() + type.slice(1)} Workout`,
            startTime,
            status: "recording",
            metrics: { duration: 0 },
            plannedActivityId,
            settings: get().workoutSettings,
            autoGenerated: !name && !plannedActivityId,
          };

          // Start the activity recorder service
          // TODO: Get profileId from auth store or pass as parameter
          const profileId = "temp-profile-id"; // This should come from auth context
          await ActivityRecorderService.startRecording(profileId);

          set({
            activeWorkout: newWorkout,
            isRecording: true,
            isPaused: false,
            hasActiveSession: true,
            currentMetrics: { duration: 0 },
          });
        } catch (error) {
          console.error("Workout Store: Failed to start workout:", error);
          throw error;
        }
      },

      pauseWorkout: async () => {
        const { activeWorkout } = get();
        if (!activeWorkout || activeWorkout.status !== "recording") {
          return;
        }

        try {
          await ActivityRecorderService.pauseRecording();

          set((state) => ({
            activeWorkout: state.activeWorkout
              ? { ...state.activeWorkout, status: "paused" as WorkoutStatus }
              : null,
            isRecording: false,
            isPaused: true,
          }));
        } catch (error) {
          console.error("Workout Store: Failed to pause workout:", error);
          throw error;
        }
      },

      resumeWorkout: async () => {
        const { activeWorkout } = get();
        if (!activeWorkout || activeWorkout.status !== "paused") {
          return;
        }

        try {
          await ActivityRecorderService.resumeRecording();

          set((state) => ({
            activeWorkout: state.activeWorkout
              ? { ...state.activeWorkout, status: "recording" as WorkoutStatus }
              : null,
            isRecording: true,
            isPaused: false,
          }));
        } catch (error) {
          console.error("Workout Store: Failed to resume workout:", error);
          throw error;
        }
      },

      stopWorkout: async () => {
        const { activeWorkout } = get();
        if (!activeWorkout) {
          return;
        }

        try {
          await ActivityRecorderService.stopRecording();

          const endTime = new Date();
          const duration = Math.floor(
            (endTime.getTime() - activeWorkout.startTime.getTime()) / 1000,
          );

          set((state) => ({
            activeWorkout: state.activeWorkout
              ? {
                  ...state.activeWorkout,
                  status: "stopped" as WorkoutStatus,
                  endTime,
                  metrics: {
                    ...state.activeWorkout.metrics,
                    duration,
                  },
                }
              : null,
            isRecording: false,
            isPaused: false,
          }));
        } catch (error) {
          console.error("Workout Store: Failed to stop workout:", error);
          throw error;
        }
      },

      completeWorkout: async () => {
        const { activeWorkout, stopWorkout } = get();
        if (!activeWorkout) {
          return;
        }

        try {
          // Stop recording if still active
          if (
            activeWorkout.status === "recording" ||
            activeWorkout.status === "paused"
          ) {
            await stopWorkout();
          }

          // Mark as completed and save
          set((state) => ({
            activeWorkout: state.activeWorkout
              ? { ...state.activeWorkout, status: "completed" as WorkoutStatus }
              : null,
            hasActiveSession: false,
          }));

          // Save to database would happen here via ActivityService

          // Clear after a short delay to allow UI to show completion
          setTimeout(() => {
            get().clearActiveWorkout();
          }, 2000);
        } catch (error) {
          console.error("Workout Store: Failed to complete workout:", error);
          throw error;
        }
      },

      updateMetrics: (metrics: Partial<WorkoutMetrics>) => {
        set((state) => ({
          currentMetrics: { ...state.currentMetrics, ...metrics },
          activeWorkout: state.activeWorkout
            ? {
                ...state.activeWorkout,
                metrics: { ...state.activeWorkout.metrics, ...metrics },
              }
            : null,
        }));
      },

      updateSettings: (settings: Partial<WorkoutSettings>) => {
        set((state) => ({
          workoutSettings: { ...state.workoutSettings, ...settings },
        }));
      },

      setShowMetrics: (show: boolean) => {
        set({ showMetrics: show });
      },

      setSelectedMetricView: (view: "basic" | "advanced" | "zones") => {
        set({ selectedMetricView: view });
      },

      clearActiveWorkout: () => {
        set({
          activeWorkout: null,
          isRecording: false,
          isPaused: false,
          hasActiveSession: false,
          currentMetrics: defaultMetrics,
        });
      },

      recoverWorkout: async () => {
        try {
          // Check if ActivityRecorderService has a session to recover
          const currentSession = ActivityRecorderService.getCurrentSession();

          if (currentSession) {
            // Recover the session state
            const isRecording = ActivityRecorderService.isRecording();
            const isPaused = ActivityRecorderService.isPaused();

            set({
              hasActiveSession: true,
              isRecording,
              isPaused,
              activeWorkout: {
                id: currentSession.id,
                type: "running", // Default type, could be enhanced
                name: "Recovered Workout",
                startTime: currentSession.startTime,
                status: currentSession.status as WorkoutStatus,
                metrics: { duration: 0 },
                settings: get().workoutSettings,
                autoGenerated: true,
              },
            });
          }
        } catch (error) {
          console.error("❌ Workout Store: Failed to recover workout:", error);
        }
      },
    }),
    {
      name: "turbofit-workout-store",
      storage: createJSONStorage(() => AsyncStorage),
      partialize: (state) => ({
        // Persist workout settings and some state
        workoutSettings: state.workoutSettings,
        selectedMetricView: state.selectedMetricView,
        showMetrics: state.showMetrics,
        hasActiveSession: state.hasActiveSession,
        // Don't persist activeWorkout as it should be recovered from ActivityRecorderService
      }),
    },
  ),
);

// Convenience hooks
export const useActiveWorkout = () =>
  useWorkoutStore((state) => state.activeWorkout);
export const useIsRecording = () =>
  useWorkoutStore((state) => state.isRecording);
export const useWorkoutMetrics = () =>
  useWorkoutStore((state) => state.currentMetrics);
export const useWorkoutSettings = () =>
  useWorkoutStore((state) => state.workoutSettings);
export const useHasActiveSession = () =>
  useWorkoutStore((state) => state.hasActiveSession);
